二叉树的最大深度
================

Essential：Recursive
--------------------

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the
root node down to the farthest leaf node.

**Note:** A leaf is a node with no children.

**Example:**

Given binary tree `[3,9,20,null,null,15,7]`,

        3
       / \
      9  20
        /  \
       15   7

return its depth = 3.

Mine
----

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left=maxDepth(root.left)+1;
        int right=maxDepth(root.right)+1;
        return Math.max(left,right);
    }
    
}
```

Discussion
----------

第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，`range(len(queue))`使只遍历当前的层，每次大循环`ans`加1。由于每个节点仅访问一次，所以时间复杂度`O(n)`

``` python
import collections
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = collections.deque()
        queue.append(root)
        ans = 0
        while queue:
            ans += 1
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return ans
```

第二种方法：DFS深度优先搜索，利用递归的栈，借助`level`标记当前层，由于每个节点仅访问一次，所以时间复杂度`O(n)`

``` python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.ans = 0
        self._dfs(root, 0)
        return self.ans
        
    def _dfs(self, node, level):
        if not node:
            return
        if self.ans < level + 1:
            self.ans = level + 1
        self._dfs(node.left, level + 1)
        self._dfs(node.right, level + 1)
```

第三种方法：DFS+分治，虽然代码简洁但耗时比上面两种方法都久

``` python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

C语言，经典算法了

``` {.c}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int maxDepth(struct TreeNode* root){
    if(root == NULL)
        return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return left>right?left+1:right+1;
}
```

验证二叉搜索树
==============

Recursive! Recursive! And Recursive!
------------------------------------

Given a binary tree, determine if it is a valid binary search tree
(BST).

Assume a BST is defined as follows:

-   The left subtree of a node contains only nodes with keys **less
    than** the node's key.
-   The right subtree of a node contains only nodes with keys **greater
    than** the node's key.
-   Both the left and right subtrees must also be binary search trees.

**Example 1:**

``` java
    2
   / \
  1   3

Input: [2,1,3]
Output: true
```

**Example 2:**

``` java
    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

I can't solve that😅
-------------------

主要是边界的问题一直没解决然后超时了。。。

Discussion
----------

``` java
class Solution {
    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null)
            return true;

        int val = node.val;
        if (lower != null && val <= lower)
            return false;
        if (upper != null && val >= upper)
            return false;

        if (!helper(node.right, val, upper))
            return false;
        if (!helper(node.left, lower, val))
            return false;
        return true;
    }

    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
}
```

> 官方答案，很妙，但是凭空我是想不起来的。

``` java
//如果不用递归，而用栈实现前序：

class Solution {
    Stack<TreeNode> st = new Stack<>();
    Stack<Long> upperList = new Stack<>(), 
        lowerList = new Stack<>();
        
    public boolean isValidBST(TreeNode root) {
        long lower = Long.MIN_VALUE, upper = Long.MAX_VALUE, val;
        update(root, lower, upper);
        while (!st.empty()) {
            root = st.pop();
            lower = lowerList.pop();
            upper = upperList.pop();
            if (root == null) continue;
            val = (long)root.val;
            if (val <= lower) return false;
            if (val >= upper) return false;
            update(root.right, val, upper);
            update(root.left, lower, val);
        }
        return true;
    }

    void update(TreeNode node, long lower, long upper) {
        st.push(node);
        lowerList.push(lower);
        upperList.push(upper);
    }
}
```

字符串转换整数 (atoi)
=====================

atChar!
-------

Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary
until the first non-whitespace character is found. Then, starting from
this character, takes an optional initial plus or minus sign followed by
as many numerical digits as possible, and interprets them as a numerical
value.

The string can contain additional characters after those that form the
integral number, which are ignored and have no effect on the behavior of
this function.

If the first sequence of non-whitespace characters in str is not a valid
integral number, or if no such sequence exists because either str is
empty or it contains only whitespace characters, no conversion is
performed.

If no valid conversion could be performed, a zero value is returned.

**Note:** \* Only the space character ' ' is considered as whitespace
character. \* Assume we are dealing with an environment which could only
store integers within the 32-bit signed integer range: \[−231, 231 −
1\]. If the numerical value is out of the range of representable values,
INT\_MAX (231 − 1) or INT\_MIN (−231) is returned.

> Example

``` java
Input: "42"
Output: 42
```

``` java
Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.            
```

俺不会写（2 ms）
----------------

``` java
class Solution {
    public int myAtoi(String str) {
    str = str.trim();  
    if (str.isEmpty()) return 0;  
  
    // 正负号标记  
    int sign = 1;  
  
    // 转换值  
    int base = 0;  
  
    // 索引位数  
    int i = 0;  
  
  
    // 判断正负号  
    if (str.charAt(i) == '-' || str.charAt(i) == '+')  
        sign = str.charAt(i++) == '-' ? -1 : 1;  
  
    // 索引有效数字字符  
    while (i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {   
        // 如果base > MAX_VALUE/10，那么base*10 + new_value > base*10 > MAX_VALUE，这种情况下就会发生溢出。  
        // 若base == INT_MAX/10，而且new_value = str.charAt(i++) - '0'`大于`7`，也会发生溢出。因为MAX_VALUE = 2147483647  
        if (base > Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 && str.charAt(i) - '0' > 7)) {  
            return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE;  
        }  
  
        // 计算转换值  
        base = 10 * base + (str.charAt(i++) - '0');  
    }  
  
    // 计算结果值  
    return base * sign;  
    }
}
```

验证回文字符串
==============

REGEX is important!
-------------------

Given a string, determine if it is a palindrome, considering only
alphanumeric characters and ignoring cases.

**Note:** For the purpose of this problem, we define empty string as
valid palindrome.

> Example

``` java
Input: "A man, a plan, a canal: Panama"
Output: true
```

我的（39 ms 😆 ）
----------------

``` java
class Solution {
    public boolean isPalindrome(String s) {
          if (s.length()<2){
              return true;
          }
          String s1 = s.replaceAll("[^a-z^A-Z^0-9]", "");
                 s1 = s1.toLowerCase();
          System.out.println(s1);
          char [] hui = s1.toCharArray();
          int  n      = s1.length();
          for(int i=0;i<(n/2);i++){
              if (hui[i] != hui[n-i-1]){
                  return false;
              }
          }
          return true;
      }
  }
```

> 先用正则表达式把数组中非字母和数字的部分去掉，然后把大写字母转成小写字母。然后就是简单的双指针替换。当然这个算法的性能非常糟糕，不过这也引起我的哲思：因为大多数高性能算法是以牺牲简易为代价的，那么我们发明那些高度封装的函数到底是为了什么呢？

2ms
---

``` java
class Solution {
    public boolean isPalindrome(String s) {
        int i = 0;
        int j = s.length() - 1;
        while(i < j){
            char c1 = validChar(s.charAt(i));
            char c2 = validChar(s.charAt(j));
            if(c1 != '\0'){
                if(c2 != '\0'){              
                    if(c1 == c2){
                        i++;
                        j--;
                    }else{
                        return false;
                    }
                }else{
                    j--;
                }
            }else{
                i++;
            }
        }
        return true;
    }

    public char validChar(char c){
        if( (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')){
            if(c >= 'A' && c <= 'Z'){
                return (char)(c + 32);
            }
            return c;
        }
        return '\0';
    }
}
```

4 ms
----

``` java
class Solution {
     public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        while(i < j){
            while(i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;
            while(i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;
            if(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;
            i++; j--;
        }
        return true;
    }

}
```

> 不过这也提醒我要尽可能都多掌握这些函数的用法。

反转字符串
==========

So easy to solve, needless to practise
--------------------------------------

Write a function that reverses a string. The input string is given as an
array of characters char\[\].

Do not allocate extra space for another array, you must do this by
modifying the input array in-place with O(1) extra memory.

You may assume all the characters consist of printable ascii characters
\#\# Example

    Input: ["h","e","l","l","o"]
    Output: ["o","l","l","e","h"]

我的（ 1 ms ）
--------------

``` java
public void reverseString(char[] s) {
        char tem='a';
        for (int i=0;i<s.length/2;i++){
            tem=s[i];
            s[i]=s[s.length-i-1];
            s[s.length-i-1]=tem;
        }
    }
```

没啥难的 ╮(╯▽╰)╭

1 ms
----

``` java
class Solution {
    public void reverseString(char[] s) {
        int i = 0, j = s.length -1;
        while (i < j) {
            char t = s[i];
            s[i] = s[j];
            s[j] = t;
            i++;
            j--;
        }
    }
}
```

外观数列
========

Ke Ba An NB Huai Le !!
----------------------

The count-and-say sequence is the sequence of integers with the first
five terms as following:

> Example

``` java
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

> 1 is read off as "one 1" or 11. 11 is read off as "two 1s" or 21. 21
> is read off as "one 2, then one 1" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the
count-and-say sequence. You can do so recursively, in other words from
the previous member read off the digits, counting the number of digits
in groups of the same digit.

**Note:** Each term of the sequence of integers will be represented as a
string.

我的（14 ms）
-------------

``` java
String countAndSay(int n){
        if (n==1){
            return "1";
        }
        if (n==2){
            return "11";
        }
        else {
            String before = countAndSay(n-1);
            int    i      = 0;
            int    j      = 1;
            int    count  = 1;
            String re     = new String();
            
            while( i < before.length() ){
                while( j < before.length() ){
                    if( before.charAt(i)==before.charAt(j) ){
                        j++;
                        count++;
                        if(j>=before.length()){
                            re = re.concat(Integer.toString(count)).concat(""+before.charAt(i));
                            
                            return re;
                        }

                    }
                    else{
                        re    = re.concat(Integer.toString(count)).concat(""+before.charAt(i));
                        i     = j;
                        count = 1;
                        j++;
                        if(j>=before.length()){
                            re = re.concat(Integer.toString(count)).concat(""+before.charAt(i));
                            
                            return re;
                        }
                        

                    }
                }
            }
            return re;
        }
        
        
    }
```

> 其实就是简单的递归，但是不知道,同样是递归，为什么这个性能这么差？

0 ms
----

``` java
public class Solution {
    public String countAndSay(int n) {
        switch (n) {
        case 1:
            return "1";
        case 2:
            return "11";
        case 3:
            return "21";
        case 4:
            return "1211";
        case 5:
            return "111221";
        case 6:
            return "312211";
        case 7:
            return "13112221";
        case 8:
            return "1113213211";
        case 9:
            return "31131211131221";
        case 10:
            return "13211311123113112211";
        case 11:
            return "11131221133112132113212221";
        case 12:
            return "3113112221232112111312211312113211";
        case 13:
            return "1321132132111213122112311311222113111221131221";
        case 14:
            return "11131221131211131231121113112221121321132132211331222113112211";
        case 15:
            return "311311222113111231131112132112311321322112111312211312111322212311322113212221";
        case 16:
            return "132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211";
        case 17:
            return "11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221";
        case 18:
            return "31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211";
        case 19:
            return "1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221";
        case 20:
            return "11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211";
        case 21:
            return "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221";
        case 22:
            return "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211";
        case 23:
            return "111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221";
        case 24:
            return "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211";
        case 25:
            return "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221";
        case 26:
            return "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211";
        case 27:
            return "31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221";
        case 28:
            return "13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211";
        case 29:
            return "11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221";
        case 30:
            return "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211";
        default:
            return "0";
        }

    }
}
```

> 这说明判断对于计算机性能的消耗是非常小的，当然像这哥们这样作弊的也不是第一次看见了，但是别人都是针对一两个值进行优化，全部举特殊值我还是第一次看见。。。

1 ms
----

``` java
class Solution {
    public String countAndSay(int n) {

        if (n == 1){
            return "1";
        }

        String str = countAndSay(n - 1);

        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < str.length(); i++) {

            int count = countAndSaySearch(str,i);

            char c = str.charAt(i);

            builder.append(count).append(c);

            i = i + count - 1;

        }

        return builder.toString();


    }

    public  int countAndSaySearch(String str,int i){

        char c = str.charAt(i);

        int count = 0;

        for (int j = i; j < str.length(); j++) {

            if (c == str.charAt(j)){
                count++;
            }else {
                break;
            }

        }

        return count;


    }

}
```

字符串中的第一个唯一字符
========================

From process-oriented thinking to object-oriented thinking
----------------------------------------------------------

Given a string, find the first non-repeating character in it and return
it's index. If it doesn't exist, return -1.

Example
-------

    s = "leetcode"
    return 0.
    
    s = "loveleetcode",
    return 2.

**Note:** \> You may assume the string contain only lowercase letters.

我的（ 2 ms ）
--------------

``` java
public int firstUniqChar(String s) {
        int len = s.length();
        for (char k = 'a'; k <= 'z'; k++) {
            int p1 = s.indexOf(k);// -1 不存在
            int p2 = s.lastIndexOf(k);
            if (p1 == p2 && p1 != -1) {
                len = Math.min(len, p1);
            }
        }
        if (len == s.length()) {
            return -1;
        }
        return len;
    }
}
```

> 从字母而不是数组开始扫描。

官方
----

``` java
public int firstUniqChar(String s) {
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int n = s.length();
                
             for(int i = 0; i<n; i++){
                     char c = s.charAt(i);
                     map.put(c, map.getOrDefault(c,0)+1);
                 }
                
                 for(int j = 0; j<n;j++){
                     if(map.get(s.charAt(j)) == 1){
                         return j;
                     }
                 }  
                 return -1;
    }
```

实现 strStr()
=============

It's so weird for language like Java to do this problem
-------------------------------------------------------

Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if
needle is not part of haystack.

> Example

``` java
Input: haystack = "hello", needle = "ll"
Output: 2
```

``` java
Input: haystack = "aaaaa", needle = "bba"
Output: -1           
```

> What should we return when needle is an empty string? This is a great
> question to ask during an interview.

> For the purpose of this problem, we will return 0 when needle is an
> empty string. This is consistent to C's strstr() and Java's indexOf().

俺的（0 ms）
------------

``` java
class Solution {
   public int strStr(String haystack, String needle) {
        if ( needle == "" ) {
            return 0;
        }
       
        return haystack.indexOf(needle);
    }
}
```

好奇怪啊，题目所要求的功能java已经被内置在string类里面了，那当然是用官方的快了。

1 ms
----

``` java
class Solution {
    public int strStr(String haystack, String needle) {
        if (haystack != null && needle != null) {

            if (needle.equals(haystack)) {
                return 0;
            }
            
            int l1 = haystack.length();
            int l2 = needle.length();
            if (l1 >= l2) {
                for (int i = 0; i < l1; i++) {
                    if ((l1 - i) >= l2 && haystack.substring(i, i + l2).equals(needle)) {
                        return i;
                    }
                }
            }
        }

        return -1;
    }
}
```

### Java substring() 方法

substring() 方法返回字符串的子字符串。

#### 语法

``` java
public String substring(int beginIndex)

或

public String substring(int beginIndex, int endIndex)
```

#### 参数

``` java
beginIndex -- 起始索引（包括）, 索引从 0 开始。

endIndex -- 结束索引（不包括）。
```

#### 例子

``` java
public class Test {
    public static void main(String args[]) {
        String Str = new String("www.runoob.com");
 
        System.out.print("返回值 :" );
        System.out.println(Str.substring(4) );
 
        System.out.print("返回值 :" );
        System.out.println(Str.substring(4, 10) );
    }
}

返回值 :runoob.com
返回值 :runoob
```

整数反转
========

又是一次失败的Debug型编程呢\_(:з」∠)\_
--------------------------------------

Given a 32-bit signed integer, reverse digits of an integer.

Example
-------

    Input: 123
    Output: 321
    
    Input: -123
    Output: -321
    
    Input: 120
    Output: 21

**Note:** \> Assume we are dealing with an environment which could only
store integers within the 32-bit signed integer range: \[−231, 231 −
1\]. For the purpose of this problem, assume that your function returns
0 when the reversed integer overflows.

我的（ 3 ms ）
--------------

``` java
public int reverse(int x) {
        if (x > 2147483647||x <= -2147483648){
            return 0;//防止输入溢出
        }
        int y =Math.abs(x);//防止负数
        String str   = String.valueOf(y);   
        int [] tmp   = new int[str.length()];
        for(int i=0;i<str.length();i++){
        tmp[i] = Integer.parseInt(String.valueOf(str.charAt(i)));
        }

        long sum=0;//防止输出溢出

        for(int j=tmp.length-1;j>=0;j--){
        sum=sum*10+tmp[j];
        }

        if (x<0){
            sum= 0-sum ;//恢复负数
        }
        if (sum > 2147483647||sum < -2147483648){
            return 0;//防止输出溢出

        }
        
        return (int)sum;

    }
```

> 先把数字转换成数组，然后再把数组转换回数字，中间处理好负数和溢出的问题。

1 ms
----

``` java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while(x != 0){
            int pop = x % 10;
            x = x / 10;
            if(rev > Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 && pop > Integer.MAX_VALUE % 10)){
                rev = 0;
                break;
            }else if(rev < Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 && x < Integer.MIN_VALUE % 10)){
                rev = 0;
                break;
            }
            rev = rev * 10 + pop;
        }
        return rev;
    }
}
```

2 ms （谁都不服就服你！）
-------------------------

``` java
class Solution {
    public int reverse(int x) {
       long n = 0;
       while(x!=0){
           n = n*10 + x%10;
           x/=10;
       }
       return (int)n==n? (int)n:0;//牛逼！！
    }
}
```

最长公共前缀
============

SubString is important !!!
--------------------------

Write a function to find the longest common prefix string amongst an
array of strings.

If there is no common prefix, return an empty string \"\". \> Example

``` java
Input: ["flower","flow","flight"]
Output: "fl"
```

``` java
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```

**Note:**

All given inputs are in lowercase letters a-z

我写不出来（0 ms）
------------------

``` java
class Solution {
 public static String longestCommonPrefix(String[] strs) {
    int count = strs.length;
    String prefix = "";
    if(count != 0){
        prefix = strs[0];
    }
    for(int i=0; i<count; i++){
        while(!strs[i].startsWith(prefix)){
            prefix = prefix.substring(0, prefix.length()-1);
        }
    }
    return prefix;
}
}
```

> 这题真是一波三折，因为之前做过最长前缀字符串的相关问题，我本来准备打算做XOR，但是发现字符串不能做XOR，我就想先把字符串转成数字，然后再用数字XOR再转回字符串，然后发现数字并不能转回字符串，数字只能转回数字字符！然后我就用普通方法试了一下，结果失败了几次以后心态崩了，就不高兴写了\_(:з」∠)\_

> 关键代码在于不断对比字符串，减少字符数量，直到startsWith()返回true。

### 字符串部分的算法就到此结束了。

有效的字母异位词
================

Map is fast !
-------------

Given two strings s and t , write a function to determine if t is an
anagram of s.

> Example

``` java
Input: s = "anagram", t = "nagaram"
Output: true
```

我的（4 ms）
------------

``` java
public boolean isAnagram(String s, String t) {
        if (s.length()!=t.length()){
            return false;
        }
        char a[] = s.toCharArray();
        char b[] = t.toCharArray();
        
        Arrays.sort(a);
        
        Arrays.sort(b);
        
        if (Arrays.equals(a, b)){
            return true;
        }

        return false;
    }
```

> 先把字符串转化为字符数组，然后对字符数组进行排序，最后比较。

2ms
---

``` java
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s == null || t == null || s.length() != t.length())
            return false;
        int[] map = new int[26];
        for(char c : s.toCharArray()){
            map[c-'a']++;
        }
        for(char c : t.toCharArray()){
            map[c-'a']--;
        }

        for(int i = 0;i<26;i++){
            if(map[i]!= 0)
                return false;
        }
        return true;
    }
}
```

合并两个有序数组
================

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1*
中*，*使 *num1* 成为一个有序数组。

**说明:**

-   初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n* 。
-   你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存
    *nums2* 中的元素。

**示例:**

``` java
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

Mine
----

``` java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1, 0, m + n);
    }
}
```

应该是最容易理解的，但是性能较差。

Standard Answer
---------------

``` java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1,p2 = n - 1,p = (n + m) - 1;
        while(p1 >= 0 && p2 >= 0){
            nums1[p--] = nums1[p1] < nums2[p2] ? nums2[p2 --] : nums1[p1 --];
        }
        System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
    }
}
```

> 倒着排序！关键在于`nums2[p2 --] : nums1[p1 --]`边录边减。

``` java
arrayCopy( arr1, 2, arr2, 5, 10);
```

意思是：将arr1数组里从索引为2的元素开始,
复制到数组arr2里的索引为5的位置, 复制的元素个数为10个。

C++
---

``` {.cpp}
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int last=m+n-1;
        while(n){
            if(m==0||nums1[m-1]<=nums2[n-1]){
                nums1[last--]=nums2[--n];
            }else{
                nums1[last--]=nums1[--m];
            }
        }
    }
};
```

两个数组的交集
==============

Stupid man are always struggling ！！
-------------------------------------

给定两个数组，编写一个函数来计算它们的交集。

> 示例 1:

    输入: nums1 = [1,2,2,1], nums2 = [2,2]
    输出: [2,2]

> 示例 2:

    输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
    输出: [4,9]

我的
----

``` swift
func intersect(_ nums1: [Int], _ nums2: [Int]) -> [Int] {
    
    var re1=nums1.sorted()
    var re2=nums2.sorted()
    
    if re1.isEmpty||nums2.isEmpty{
        return []
    }
    
    var i:Int = -1
    var j:Int = -1
    
    if(re1.count<=re2.count){
        for _ in 0..<re1.count{
            i+=1
            j = -1
            for _ in 0..<re2.count{
                j+=1
                if re1[i] == re2[j]{
                    re2.remove(at: j)
                    j-=1
                    break
                }
                else{
                    if (j==re2.count-1||re1[i]<re2[j]) {
                        re1.remove(at: i)
                        i-=1
                        break
                    }
                }
            }
        }
        
    }else{
        for _ in 0..<re2.count{
        i+=1
        j = -1
        for _ in 0..<re1.count{
            
            j+=1
            if re2[i] == re1[j]{
                re1.remove(at: j)
                j-=1
                break
            }
            else{
                if (j==re1.count-1||re2[i]<re1[j]) {
                    re2.remove(at: i)
                    i-=1
                    break
                }
            }
        }
        }
        return re2
    }
    return re1
}
```

$$愚蠢的人总是事倍功半  —— Gaochengzhi$$

我花了好大力气来Debug，设计了两个解决数组删除问题的 i, j
变量，优化了数组长短的选择方案，最后程序通过了，但是性能非常差，记得就在几天之前我还嘲笑过一个把代码写的老长却却获得糟糕性能分数的人。那时我用很简短的代码就击败了99%的选手。

~~人果然还是要谦虚一点好啊。~~

这不禁令我反思，我生命中遇到过的很多人，他们花了巨大的力气做某件事，事实上被证明只是浪费时间和精力罢了。啊！愚蠢又可悲的人类呀！

24 ms
-----

``` swift
class Solution {
    func intersect(_ nums1: [Int], _ nums2: [Int]) -> [Int] {
        var dict:[Int:Int] = [:]
        var array:[Int] = []
        for i in 0..<nums1.count {
            let value = nums1[i]
            var dVlue = dict[value] ?? 0
            dVlue += 1
            dict[value] = dVlue
        }
        for i in 0..<nums2.count {
            let value = nums2[i]
            var dVlue = dict[value] ?? 0
            if dVlue > 0 { 
                dVlue -= 1
                array.append(value)
                dict[value] = dVlue
            }
        }
        return array
    }
}
```

-   使用map\[数字为key，数字个数为value\]记录数字和数字个数
-   遍历数组2，map\[num\]的值大于0的就是两个数组共有的数字，然后map\[num\]-=1
-   返回添加数字的数组

或者：
------

但是不知道为什么会慢很多

``` swift
func intersect(_ nums1: [Int], _ nums2: [Int]) -> [Int] {
    var result = [Int]()
    var tmp = [Int:Int]()
    for num in nums1 {
        var t = tmp[num] ?? 0
        t+=1
        tmp.updateValue(t, forKey: num)
    }
    for n in nums2 {
        let tt = tmp[n] ?? 0
        if tt > 0 {
            result.append(n)
            tmp[n]!-=1
        }
    }
    return result
}
```

两数之和
========

Dictionary is a thing that you must learn
-----------------------------------------

给定一个整数数组 nums 和一个目标值
target，请你在该数组中找出和为目标值的那 两个
整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

Example
-------

> 给定 nums = \[2, 7, 11, 15\], target = 9
>
> 因为 nums\[0\] + nums\[1\] = 2 + 7 = 9 所以返回 \[0, 1\]

我的（ 800 ms ）
----------------

``` swift
func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        var sim = [0,0]
        for i in 0..<nums.count{
            for j in i+1..<nums.count{
                if (nums[i]+nums[j]==target) {
                    sim[0]=i
                    sim[1]=j
                }
            }
        }
        return sim
    }
```

双层循环在节省空间上有优势，但是现在硬盘已经这么便宜了，要节省空间干什么！！！还是时间最宝贵啊！！！

20 ms
-----

``` swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        let count = nums.count
     
        var dic = [Int : Int]()
        
        for i in 0..<count {
            dic[nums[i]] = i
        }
        
        for i in 0..<count {
            let found = target - nums[i]
            if let j = dic[found], i != j {
                return [i, j]
            }
        }
        return []
    }
}
```

字典这么快的吗？？

买卖股票最佳时期
================

tradtional two-point solution
-----------------------------

给定一个数组，它的第 i 个元素是一支给定股票第 i
天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票)。

> Example:
>
> 输入: \[7,1,5,3,6,4\]
>
> 输出: 7
>
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票j价格 =
> 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4
> 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出,
> 这笔交易所能获得利润 = 6-3 = 3 。

我的：
------

``` swift
class Solution {
        func maxProfit(_ prices: [Int]) -> Int {
        var i = 0 //    Slow point
        var pro = 0
            if prices.count==0{
            //  in case []!!
            }
            else {
            for j in 1..<prices.count{
                if (prices[j]-prices[i]>=0){
                    pro+=prices[j]-prices[i]       
                    }
                i+=1
                }   
            }
        return pro;
        }
    }
```

36 ms的解答
-----------

``` swift
class Solution {
        func maxProfit(_ prices: [Int]) -> Int {
            if prices.count <= 1 {
                return 0
            }
            var pre = prices[0]
            var res = 0
        
            for cur in 1..<prices.count {
                let price = prices[cur]
                if price > pre {
                    res += (price - pre)
                }
                pre = price
            }
            return res
        }
}
```

优化
----

``` swift
 func maxProfit(_ prices: [Int]) -> Int {
    
    if prices.count == 0 {
        return 0}
    var pro = 0
    for i in 1..<prices.count{
        if (prices[i]-prices[i-1]>0){
            pro+=prices[i]-prices[i-1]
        }
    }
        return pro;
}
```

-   201 / 201 个通过测试用例
-   状态：通过
-   执行用时：48 ms
-   内存消耗：20.8 MB

Java 我的提交
-------------

``` java
class Solution {
    public int maxProfit(int[] prices) {
       int pro = 0;
        if (prices.length == 0) {
        }
        else{
            
            for (int i=1;i<=prices.length;i++) {
                if (prices[i]-prices[i-1]>0){
                    pro+=prices[i]-prices[i-1];
                }
            }
        }
        return pro;
       }
    }
```

-   201 / 201 个通过测试用例
-   状态：通过
-   执行用时：1 ms
-   内存消耗：42 MB

加一
====

Please remain simple
--------------------

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数。
你可以假设除了整数 0 之外，这个整数不会以零开头。

Example
-------

> 输入: \[1,2,3\] 输出: \[1,2,4\] 解释: 输入数组表示数字 123。

我的
----

``` swift
func plusOne(_ digits: [Int]) -> [Int] {
    var realdigits = digits
    
    var i = realdigits.count-1
    if i < 0{
        return []
    }
    if realdigits[i] != 9 {
        realdigits[i]+=1
    }else{
        while realdigits[i] >= 9 {
            realdigits[i] = 0
            if i==0 {
                realdigits.insert(1, at: 0)
                break
            }            
            i-=1
            if realdigits[i] == 8 {
                realdigits[i]+=1
                break
            }
            realdigits[i]+=1
        }
    }
    return realdigits
}
```

> 简直是Debug型编程啊真是糟糕透了，性能也一般，50%吧。

网上找了几个思路都和我都差不多，性能也一模一样。\
\#\# 4 ms

``` swift
func plusOne(_ digits: [Int]) -> [Int] {
        if digits.count < 0 {
            return []
        }
        var newDigits = digits
        for i in stride(from: digits.count - 1, through: 0, by: -1) {
            if newDigits[i] < 9 {
                newDigits[i] += 1
                return newDigits
            }
            newDigits[i] = 0
        }
        newDigits.insert(1, at:0)
        return newDigits
    }
}
```

这个为啥这么快？？和它应该一样思路的只有它的1/3，难道
`for i in stride(from: digits.count - 1, through: 0, by: -1) {` 和
`.reversed` 这么不一样吗？

只出现一次的数字
================

Get to learn something new ! exclusive OR
-----------------------------------------

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

> 说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

> 示例:

    输入: [2,2,1]
    输出: 1

> 示例 2:

    输入: [4,1,2,1,2]
    输出: 4

我的
----

``` swift
   func singleNumber(_ nums: [Int]) -> Int {
        var returnNum = 0
        for i in 0..<nums.count{
        returnNum = returnNum^nums[i]
        }
        return returnNum
    }
```

异或
----

> 1\^1 = 0 1\^1\^2 = 2 1\^1\^2\^2\^3 = 3 0和任何数异或得其本身

Java
----

> 比较法

　　思路：先对数组进行排序，然后对 nums\[i\] 和 nums\[i +
1\]进行比较，如相等，i+=2，继续下一组比较，直到取到不相等的一组。

　　注意：首先这个数组的长度肯定是奇数（目标数字只出现一次，其他所有数字出现两次），所以如果上述步骤没有找到不相等的一组数，那么肯定是数组的最后一个数字是单独出现的。
　　

``` java
 1　  public static int singleNumber(int[] nums) {
 2         Arrays.sort(nums);  // 排序数组
 3         for (int i = 0; i < nums.length - 1; i += 2) {
 4             // 找到不相等的一组，直接返回
 5             if (nums[i] != nums[i + 1]) {
 6                 return nums[i];
 7             }
 8         }
 9         // 如果没有找到不相等的一组数据，直接返回数组的最后一个数字
10         return nums[nums.length - 1];
11     }
```

`<br/>`{=html} \> 方法二（去重法）：

　　思路：利用HashSet的特性，删除重复的数组元素，最后剩下一个单独的元素，返回即可。

``` java
1   public static int singleNumber(int[] nums) {
2         Set<Integer> set = new HashSet<>();
3         for (int i = 0; i < nums.length; i++) {
4             if (!set.add(nums[i])) { // add成功返回true，如果set中已有相同数字，则add方法会返回false
5                 set.remove(nums[i]); // 删除重复出现的数字
6             }
7         }
8         return set.iterator().next();9     }
```

`<br/v>`{=html} \> 方法三（求差法）：

　　思路：先对数组排序，显而易见的，单独出现一次的数据必然是出现在数组下标为偶数的位置（下标从0开始），那么所有奇数下标的元素之和减去偶数下标的元素之和，就是需要求得的结果。
　　

``` java
1     public static int singleNumber(int[] nums) {
2         int num = 0;
3         Arrays.sort(nums);
4         for (int i = 0; i < nums.length; i++) {
5             // 偶数下标位置 num += nums[i]，奇数下标位置 num -= nums[i]
6             num = i % 2 == 0 ? num + nums[i] : num - nums[i];
7         }
8         return num;
9     }
```

存在重复
========

Don't do double circ!!
----------------------

给定一个整数数组，判断是否存在重复元素。
如果任何值在数组中出现至少两次，函数返回
true。如果数组中每个元素都不相同，则返回 false。

Example
-------

> 输入: \[1,2,3,1\] 输出: true

我的
----

``` swift
func containsDuplicate(_ nums: [Int]) -> Bool {
        let set = Set(nums)
        return set.count != nums.count
}
```

### Set 用法

> 集合（Set）是用来存储相同类型、没有确定顺序、且不重复的值。
> 也就是说当元素顺序不重要时，或者希望确保每个元素只出现一次时，可以使用集合而不是数组。

1.  创建空集合 \> Swift 中 Set 类型被写为 Set`<Element>`{=html}，这里的
    Element 表示 Set
    中允许存储的类型。下面我们通过构造器语法创建一个特定类型的空集合：

         var fruits = Set<String>()

2.  创建带初始值的集合 \> 下面我们创建一个带有三个 String
    类型的初始值的集合。

         var fruits: Set<String> = ["apple", "pear", "orange"]

    > 当然如果数组字面量中的所有元素类型相同，可以不必写 Set
    > 的具体类型。

         var fruits: Set = ["apple", "pear", "orange"]

3.  将数组转为集合

    > 由于集合里的值是不能重复的，多余的重复值将会被丢弃掉。

``` swift
    let array = ["apple", "apple", "orange"]
    let set = Set(array)
    print(set)
```

-   数组（Arrays）是有序数据的集。
-   集合（Sets）是无序无重复数据的集。
-   字典（Dictionaries）是无序的键值对的集。

168 ms
------

``` swift
func containsDuplicate(_ nums: [Int]) -> Bool {
           if nums.count <= 1 {
            return false
        }
        var array = nums
        array.sort { (a, b) -> Bool in
            return a > b
        }
        for i in 0..<array.count-1 {
            if array[i+1] == array[i] {
                return true
            }
        }
        return false
}
```

**排序思路居然更快？？Apple的sort到底咋写的？**

旋转图像
========

Math is crucial In some cases。
-------------------------------

You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify
the input 2D matrix directly. DO NOT allocate another 2D matrix and do
the rotation.

Example
-------

    Given input matrix = 
    [
      [1,2,3],
      [4,5,6],
      [7,8,9]
    ],
    
    rotate the input matrix in-place such that it becomes:
    [
      [7,4,1],
      [8,5,2],
      [9,6,3]
    ]

我的（ 20 ms ）
---------------

``` swift
func rotate(_ matrix: inout [[Int]]) {  
    var sub:Int = 0
    let len=matrix.count
    for i in 0..<len {
        for j in i+1..<len {
            sub=matrix[i][j]
            matrix[i][j]=matrix[j][i]
            matrix[j][i]=sub
        }
        matrix[i].reverse()
    }    
}
```

> 先对数组进行转置，然后倒叙行就完成了，注意第二个循环
> `for j in i+1..<len`

16 ms
-----

``` swift
func rotateImage1(_ matrix: inout [[Int]]) {
        let n = matrix.count
        for i in 0..<n/2 {
            for j in i..<(n - 1 - i) {
                let tmp = matrix[i][j]
                matrix[i][j] = matrix[n - 1 - j][i]
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]
                matrix[j][n - 1 - i] = tmp
            }
        }
    }
```

> 对于当前位置，计算旋转后的新位置，然后再计算下一个新位置，第四个位置又变成当前位置了，所以这个方法每次循环换四个数字。

``` swift
1 2 3      7 2 1      7 4 1
4 5 6 ->   4 5 6  ->  8 5 2
7 8 9      9 8 3      9 6 3
```

还有一种
--------

``` swift
func rotate(_ matrix: inout [[Int]]) {
        let n = matrix.count
        for i in 0..<(n - 1) {
            for j in 0..<(n - i) {
                let temp = matrix[i][j]
                matrix[i][j] = matrix[n - 1 - j][n - 1 - i]
                matrix[n - j - 1][n - i - 1] = temp
            }
        }
        
        for i in 0..<n/2 {
            for j in 0..<n {
                let temp = matrix[i][j]
                matrix[i][j] = matrix[n - 1 - i][j]
                matrix[n - 1 - i][j] = temp
            }
        }
    }
```

> 首先以从对角线为轴翻转，然后再以x轴中线上下翻转即可得到结果

至此数组部分就全部结束了，完结撒花！（并不）
--------------------------------------------

旋转数组
========

Using an alternative array is the most efficient and easy answer.
-----------------------------------------------------------------

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

> Example:
>
> 输入: \[1,2,3,4,5,6,7\] 和 k = 3 输出:\[5,6,7,1,2,3,4\] 解释: 向右旋转
> 1 步: \[7,1,2,3,4,5,6\] 向右旋转 2 步: \[6,7,1,2,3,4,5\] 向右旋转 3
> 步: \[5,6,7,1,2,3,4\]

我的
----

``` swift
func rotate(_ nums: inout [Int], _ k: Int) {
        var B:Array=[Int](repeating: 0, count: nums.count)
        let j=k%nums.count
        for i in 0..<nums.count{
            let num=(i+j)%nums.count
            B[num]=nums[i]
            }
        for i in 0..<nums.count {
            nums[i]=B[i]
        }
}
```

`<br/v>`{=html}\
\> 34 / 34 个通过测试用例 \> 状态：通过 \> 执行用时：48 ms \>
内存消耗：21.3 MB

有效的数独
==========

To be clear , I am unable to do so...
-------------------------------------

Determine if a 9x9 Sudoku board is valid. Only the filled cells need to
be validated according to the following rules:

1.  Each row must contain the digits 1-9 without repetition.
2.  Each column must contain the digits 1-9 without repetition.
3.  Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9
    without repetition.

Example
-------

``` swift
Input:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true
```

160 ms
------

``` swift
class Solution {
    func isValidSudoku(_ board: [[Character]]) -> Bool {
        var rowNums = Array(repeating: 0, count: 9)
        var colNums = Array(repeating: 0, count: 9)
        var boxNums = Array(repeating: 0, count: 9)
        
        for i in 0..<9 {
            for j in 0..<9 {
                if !board[i][j].isNumber {
                    continue
                }
                let num = board[i][j].wholeNumberValue ?? 0
                
                if rowNums[i] & 1 << num != 0 {
                    return false
                } else {
                    rowNums[i] |= 1 << num
                }
                
                if colNums[j] & 1 << num != 0{
                    return false
                } else {
                    colNums[j] |= 1 << num
                }
                
                let boxIndex = i / 3 * 3 + j / 3
                if boxNums[boxIndex] & 1 << num != 0 {
                    return false
                } else {
                    boxNums[boxIndex] |= 1 << num
                }
            }
        }
        return true
    }
}
```

### Swift Continue 语句

> Swift
> continue语句告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。

### 位运算符

位运算符用来对二进制位进行操作，\~ , & , \| , \^
分别为取反，按位与与，按位与或，按位与异或运算，如下表实例：

> 如果指定 A = 60; 及 B = 13; 两个变量对应的二进制为：

``` swift
A = 0011 1100

B = 0000 1101
```

### Swift 正则表达式 NSRegularExpression

#### 枚举类型

``` swift
typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
        NSRegularExpressionCaseInsensitive          = 1 << 0,   // 不区分大小写的
        NSRegularExpressionAllowCommentsAndWhitespace  = 1 << 1,   // 忽略空格和# (注释符)
        NSRegularExpressionIgnoreMetacharacters        = 1 << 2,   // 整体化
        NSRegularExpressionDotMatchesLineSeparators    = 1 << 3,   // 匹配任何字符，包括行分隔符
        NSRegularExpressionAnchorsMatchLines          = 1 << 4,   // 允许^和$在匹配的开始和结束行
        NSRegularExpressionUseUnixLineSeparators      = 1 << 5,   // (查找范围为整个的话无效)
        NSRegularExpressionUseUnicodeWordBoundaries    = 1 << 6    // (查找范围为整个的话无效)
     };
     
typedef NS_OPTIONS(NSUInteger, NSMatchingOptions)  {
        NSMatchingReportProgress         = 1 << 0, //找到最长的匹配字符串后调用block回调
        NSMatchingReportCompletion       = 1 << 1, //找到任何一个匹配串后都回调一次block
        NSMatchingAnchored               = 1 << 2, //从匹配范围的开始处进行匹配
        NSMatchingWithTransparentBounds  = 1 << 3, //允许匹配的范围超出设置的范围
        NSMatchingWithoutAnchoringBounds = 1 << 4  //禁止^和$自动匹配行还是和结束
     };
```

哦我的天哪，太多了，今天就到这里为止吧！

移动零
======

So simple and so clear
----------------------

给定一个数组 nums，编写一个函数将所有 0
移动到数组的末尾，同时保持非零元素的相对顺序。

Example
-------

> 输入: \[0,1,0,3,12\] 输出: \[1,3,12,0,0\]

我的（ 52 ms ）
---------------

``` swift
func moveZeroes(_ nums: inout [Int]) {
    var length=nums.count
    var j=0
    
    while j<length {
        if nums[j]==0{
            nums.remove(at: j)
            nums.append(0)
            length-=1
            j-=1
        }
        j+=1
    }
}
```

40 ms
-----

``` swift
class Solution {
    func moveZeroes(_ nums: inout [Int]) {
        var idx = 0
        var i = 0
        while i < nums.count {
            if nums[i] != 0 {
                nums[idx] = nums[i]
                idx += 1
            }
            i += 1
        }
        for j in idx..<nums.count {
            nums[j] = 0
        }

    }
}
```

这种方法也很好啊，将不是零的元素全部移动到最前面。

删除链表中的节点
================

Java makes ListNode really easy!
--------------------------------

Write a function to delete a node (except the tail) in a singly linked
list, given only access to that node.

Given linked list -- head = \[4,5,1,9\], which looks like following:

![img](https://tva1.sinaimg.cn/large/00831rSTgy1gcudasjnijj30az01tdfp.jpg)

**Example 1:**

``` java
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```

**Example 2:**

``` java
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Note:**

-   The linked list will have at least two elements.
-   All of the nodes' values will be unique.
-   The given node will not be the tail and it will always be a valid
    node of the linked list.
-   Do not return anything from your function.

俺的（没有时间统计）
--------------------

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

> 开始的时候折腾了老半天，因为学链表的时候是用的C语言，这太古老了。当时为了应付考试我不得不死记硬背了整个语法（C语言的指针非常难对付）导致我对链表天生有一种恐惧的心态。

删除链表的倒数第N个节点
=======================

Finally get what the ListNode is about
--------------------------------------

Given a linked list, remove the *n*-th node from the end of list and
return its head.

**Example:**

``` java
Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, 
the linked list becomes 1->2->3->5.
```

**Note:**

Given *n* will always be valid.

**Follow up:**

Could you do this in one pass?

Mine ( 2 ms \_(:з」∠)\_ )
-------------------------

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int len(ListNode head){
        int length = 1;
        while (head.next != null) {
            head = head.next;
            length++;
        }
        return length;
    }
    
    
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int length = this.len(head);
        ListNode temp = head;
        int currentPos = 0;
        
        lable_a:
        while (temp != null) {
            if (length==n){
                    head=head.next;
                    break lable_a;
            }
            
            //找到上一个节点的位置了
            if ((length-n-1) == currentPos) {
                
                //temp表示的是上一个节点
                
                //temp.next表示的是想要删除的节点

                //将想要删除的节点存储一下
                ListNode deleteNode = temp.next;

                //想要删除节点的下一个节点交由上一个节点来控制
                temp.next = deleteNode.next;

            }
            currentPos++;
            temp = temp.next;
        }
        
        return head;
    }
}
```

Standard Answer ( 0ms )
-----------------------

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head, slow = head;
        for (int i = 0; i < n; i ++) {
            if (fast != null) {
                fast = fast.next;
                continue;
            }
            throw new IllegalArgumentException("n is invalid");
        }
        if (fast == null) {
            return slow.next;
        }
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
       
        slow.next = slow.next.next;
        
        return head;
    }
}
```

> 这个乍一看很反常，但是实验一下确实是对的，但是我不明白 slow 是怎么影响
> head？
>
> 后来一想 class 天生就是引用值嘛。。 \# 反转链表

Recursive！Recursive！and Recursive！
-------------------------------------

Reverse a singly linked list.

**Example:**

``` {.cpp}
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
```

**Follow up:**

A linked list can be reversed either iteratively or recursively. Could
you implement both?

Mine (0 ms)
-----------

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if ( head == null || head.next == null ){
            return head;
        }
        
        else {
            ListNode newHead = reverseList ( head.next );
            head.next.next = head;
            head.next = null;
        
            return newHead;
        }
    }
}
```

`<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcw4emurn2j30u013yqc1.jpg" alt="Screen Shot 2020-03-16 at 10.06.56 PM" style="zoom: 50%;" />`{=html}
$$
by :https://www.jianshu.com/p/f7534f8d7bf2
$$

> 递归真是博大精深啊！！！

Standard Answer
---------------

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;        
    } 
}
```

> 哇\_(:з」∠)\_车轮战啊这是！！！但是好理解多了。 \# 合并两个有序链表

No more than a platitude
------------------------

Merge two sorted linked lists and return it as a new list. The new list
should be made by splicing together the nodes of the first two lists.

**Example:**

``` java
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```

Mine
----

``` java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);// 虚表头
        ListNode point = head;
       while (l1 != null && l2 != null) {
            if(l1.val <= l2.val){
            // 不断让表接上头
                point.next = l1;
                point = point.next;
                l1 = l1.next;
            }    
            else {
                point.next = l2;
                point = point.next;
                l2 = l2.next;
            }
       }
       if (l1 == null) {
           point.next = l2;
        } 
        else {
           point.next = l1;
        }
    return head.next;    

    }
}
```

> 我开始是准备重置两个指针互相捣腾。然后返回最原先设定的那个表头。但是做了半天发现没有办法解决有连续数字的问题，然后就是这种重新建两个指针，让本来的表头互相捣腾。方便多了。

官方答案都差不多就不贴了
------------------------

回文链表
========

一遍过我还是很开心的
--------------------

Given a singly linked list, determine if it is a palindrome.

**Example 1:**

``` java
Input: 1->2
Output: false
```

**Example 2:**

``` java
Input: 1->2->2->1
Output: true
```

**Follow up:** Could you do it in O(n) time and O(1) space?

> 注意空节点和单节点返回的是true

Mine
----

``` java
class Solution {
    public boolean isPalindrome(ListNode head) {
        int length = 0;
        int i = 0;
        ListNode count = head;
        ListNode count2 = head;
        while (count != null) {
            count = count.next;
            length++;
        }
        if (length <= 1) {
            return true;
        }

        while (i <= length / 2) {
            count = head;
            int n = 0;

            while (n < length - i - 1) {
                count = count.next;
                n++;
            }

            if (count2.val != count.val) {
                return false;
            }
            count2 = count2.next;
            i++;
        }

        return true;
    }
}
```

> 就是最简单的比对法，慢得不得了，但是这次我写完没测试就提交了，结果居然通过了！

Standard Answer
---------------

### 这里个个都是人才啊！

``` java
class Solution {
    public boolean isPalindrome(ListNode head) {
         //1.判断是否是一个节点
        if (head == null || head.next == null)  return true;
        //2判断是否是2个节点
        if (head.next.next == null) return head.val == head.next.val;
        //如果都不是
        //1.设定一个slow指针指向当前回文遍历的字符，设定一个fast指针，遍历到slow对应回文的后面的节点的前一个节点，也就是fast.next.val==slow.val
        ListNode slow = head, fast = head.next;
        //2.这样不断循环推进slow，然后把fast设置为slow.next开始遍历，循环后退，每次匹配成功，然后就把fast后面的断开，并把slow推进
        //如果匹配不成功，则继续推进fast到fast.next==null位置说明没有位置匹配了
        while (fast.next != null) {
            if (slow.val == fast.next.val) {
                //如果匹配成功
                if (fast.next.next != null) {
                    //如果不是和最后一个位置的字符匹配，说明回文中间掺杂其他字符，不连续
                    return false;
                } else {
                    fast.next = null;
                    slow = slow.next;
                    fast = slow.next;
                }
                //判断是否循环结束,这里区分奇和偶，如果是奇数个回文
                if (fast == null || (fast.next == null && slow.val == fast.val)) {
                    return true;
                }
            } else {
                fast = fast.next;
            }
        }
        return false;
    }
}
```

Answer 2
--------

``` java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null){
            return true;
        }
        // 得到中点/中点前的节点
        ListNode endOfFirstHalf = endOfFirstHalf(head);
        // 翻转后半部分
        ListNode beginOfSecondHalf = reverseNode(endOfFirstHalf.next);

        // 开始比较
        boolean isPalindrome = true;
        ListNode p1 = head;
        ListNode p2 = beginOfSecondHalf;
        while(isPalindrome && p2 != null){
            if(p1.val != p2.val) isPalindrome = false;
            p1 = p1.next;
            p2 = p2.next;
        }
        // endOfFirstHalf.next = reverseNode(beginOfSecondHalf);

        return isPalindrome;
        


    }

    private ListNode reverseNode(ListNode head){
        ListNode prev = null;
        ListNode current = head;
        while(current != null){
            // 临时存储下个节点
            ListNode tempNextNode = current.next;
            // 当前节点next指针指向前节点
            current.next = prev;
            // prev,current指针后移
            prev = current;
            current = tempNextNode;
        }
        return prev;
    }

    private ListNode endOfFirstHalf(ListNode head){
        ListNode slow = head;
        ListNode fast = head;

        // 慢指针每次走一步，快指针每次走两步
        // 若节点为基数，则中点为前半部分
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
}
```

环形链表
========

Discussion is really funny！
----------------------------

Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer `pos`
which represents the position (0-indexed) in the linked list where tail
connects to. If `pos` is `-1`, then there is no cycle in the linked
list.

**Example 1:**

    Input: head = [3,2,0,-4], pos = 1
    Output: true
    Explanation: There is a cycle in the linked list, where tail connects to the second node.

![img](https://tva1.sinaimg.cn/large/00831rSTgy1gcz8w69sx8j30er04r0sr.jpg)

**Example 2:**

    Input: head = [1,2], pos = 0
    Output: true
    Explanation: There is a cycle in the linked list, where tail connects to the first node.

![img](https://tva1.sinaimg.cn/large/00831rSTgy1gcz8w6h4owj305l02xglg.jpg)

**Example 3:**

    Input: head = [1], pos = -1
    Output: false
    Explanation: There is no cycle in the linked list.

![img](https://tva1.sinaimg.cn/large/00831rSTgy1gcz8w6q7qmj301t01twe9.jpg)

**Follow up:**

Can you solve it using *O(1)* (i.e. constant) memory?

简单解释一下
------------

这题目综述写得糟糕的很，很多人（包括我）看不懂到底是要干什么。其实就是给你一个链表，让你判断是不是环形链表，环形链表永远跑不到尾巴。

Mine
----

``` java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        if(head == null ) return false;
        ListNode fast = head.next;
        if (fast == null) {
            return false;
        }
        try{
          do {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                return true;
                    }   
             } while (fast != null);
   
        }catch(Exception e){
            return false;
        }
        return false;
    }
}
```

> 双指针法注意.next.next找不到的情况。

Discussion
----------

> 今天才看到有讨论区，真是人才辈出！

### Delay

``` {.cpp}
bool hasCycle(struct ListNode *head) {
    if(head){
        int times = 0;
        struct ListNode *root = head;
        while(root->next){
            root = root->next;
            times++;
            if(times>10000){
                return true;
            }
        }
    }
    return false;
```

### \" 我帮你们测试好了，样例最多的有8029个数据 \"

``` java
public class Solution {
    public boolean hasCycle(ListNode head) {
        int count=8029;
        
        while(head!=null&&count>0){
            head=head.next;
            count--;
        }
        if(head==null)
            return false;
            
        return true;
        
        
    }
}
```

### "想要取巧,bjfuvth什么的怪字符串不可取"

``` {.javascript}
var hasCycle = function(head) {
    let s = Symbol('fuck')
    while(head){
        if(head[s]) return true
        else head[s] = true
        head = head.next
    }
    return false
};
```

### ???

``` {.javascript}
var hasCycle = function(head) {
    try{
        JSON.stringify(head);
    }
    catch(e){
        return true;
    }
    return false;
};
```

链表部分就全部做完了！
----------------------
